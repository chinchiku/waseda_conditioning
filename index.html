<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ワセダ_覇者への道のり (v36)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts (v33と同じ) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Klee+One:wght@600&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Chart.js (グラフ描画ライブラリ) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    
    <!-- ★ v34: Firebase ライブラリを追加 -->
    <script type="module">
        // Firebase v11 (モジュール版) をインポート
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ----------------------------------------
        // グローバル変数
        // ----------------------------------------
        let conditionChart = null;
        let appData = [];
        let savedTaperPlans = [];
        
        // ★ v34: Firebase用グローバル変数
        let db;
        let auth;
        let userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // ★ v34: 保存キーを Firestore のドキュメントIDに変更
        const SETTINGS_DOC_ID = 'settingsV1';
        const MANUAL_DATA_DOC_ID = 'manualDataV1';
        const TAPER_PLANS_DOC_ID = 'taperPlansV1';

        // ★ v35: DOM要素の「宣言」をグローバルスコープに移動
        // ページ切り替え
        let navLinks;
        let pages;
        let mobileMenuButton;

        // 設定ページ
        let csvUrlsInput, manualDataInput, saveButton, saveStatus;
        let dataSourceCsv, dataSourceManual, settingsCsvContainer, settingsManualContainer;
        let mappingInputs = {}; // mappingInputsはオブジェクトなので初期化

        // テーパリング計画ページ
        let newPlanButton, planFormContainer, planAvgDistanceSpan, savePlanButton;
        let cancelPlanButton, planOutputContainer, savedPlansList, planFormTitle;
        let planRaceName, planRaceDate, planDuration, planFinalLoad, planEditId;

        // ----------------------------------------
        // 列アルファベット <-> 数字 変換 (v33と同じ)
        // ----------------------------------------
        function columnToLetter(colNum) {
            if (colNum === null || colNum === undefined || colNum === "" || colNum < 1) {
                return "";
            }
            let letter = '';
            let num = parseInt(colNum, 10);
            while (num > 0) {
                let rem = (num - 1) % 26;
                letter = String.fromCharCode(65 + rem) + letter;
                num = Math.floor((num - 1) / 26);
            }
            return letter;
        }

        function letterToColumn(letter) {
            if (!letter || typeof letter !== 'string') {
                return null;
            }
            const cleanLetter = letter.toUpperCase().trim();
            let colNum = 0;
            for (let i = 0; i < cleanLetter.length; i++) {
                colNum = colNum * 26 + (cleanLetter.charCodeAt(i) - 64);
            }
            return colNum > 0 ? colNum : null;
        }

        // ----------------------------------------
        // 日付パーサー (v33と同じ)
        // ----------------------------------------
        
        // 「ソート用」
        function parseDateToSort(dateStr) {
            try {
                let month, day;
                let dateObj;
                const ymdMatch = dateStr.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
                const mdMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})$/);

                if (ymdMatch) {
                    const parsableDateStr = dateStr.replace(/-/g, '/') + "T00:00:00";
                    dateObj = new Date(parsableDateStr); 
                    if (isNaN(dateObj.getTime())) return null;
                    month = dateObj.getMonth() + 1;
                    day = dateObj.getDate();
                } else if (mdMatch) {
                    month = parseInt(mdMatch[1], 10);
                    day = parseInt(mdMatch[2], 10);
                    if (month < 1 || month > 12 || day < 1 || day > 31) return null;
                    const yearOffset = (month < 4) ? 1 : 0;
                    return new Date(2000 + yearOffset, month - 1, day);
                } else {
                    return null;
                }
                const sortYear = (month < 4) ? 2001 : 2000;
                return new Date(sortYear, month - 1, day);
            } catch (error) {
                console.error(`Failed to parse sort date string: ${dateStr}`, error);
                return null;
            }
        }
        
        // 「実日付用」
        function parseDateToReal(dateStr) {
            try {
                const ymdMatch = dateStr.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
                if (ymdMatch) {
                    const parsableDateStr = dateStr.replace(/-/g, '/') + "T00:00:00";
                    const dateObj = new Date(parsableDateStr);
                    if (isNaN(dateObj.getTime())) return null;
                    return dateObj;
                }
                
                const mdMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})$/);
                if (mdMatch) {
                    const month = parseInt(mdMatch[1], 10);
                    const day = parseInt(mdMatch[2], 10);
                    if (month < 1 || month > 12 || day < 1 || day > 31) return null;

                    const today = new Date();
                    today.setHours(0, 0, 0, 0); 
                    const currentYear = today.getFullYear();
                    const currentMonth = today.getMonth() + 1;
                    
                    let targetYear = currentYear;
                    
                    if (currentMonth < 4) { 
                        if (month < 4) { 
                            targetYear = currentYear;
                        } else { 
                            targetYear = currentYear - 1;
                        }
                    } else { 
                        if (month < 4) { 
                            targetYear = currentYear + 1;
                        } else { 
                            targetYear = currentYear;
                        }
                    }
                    
                    const dateObj = new Date(targetYear, month - 1, day);
                    if (isNaN(dateObj.getTime())) return null;
                    
                    if (dateObj > today) {
                        dateObj.setFullYear(dateObj.getFullYear() - 1);
                    }
                    
                    return dateObj;
                }
                
                return null; // 不明な形式
            
            } catch (error) {
                console.error(`Failed to parse real date string: ${dateStr}`, error);
                return null;
            }
        }

        // ----------------------------------------
        // ページ切り替えロジック
        // ----------------------------------------
        const defaultPage = 'page-dashboard'; 

        function showPage(pageId) {
            if (!pages) pages = document.querySelectorAll('.page-content'); // v35: 遅延初期化
            pages.forEach(page => { page.style.display = 'none'; });
            const targetPage = document.getElementById(pageId);
            if (targetPage) { 
                targetPage.style.display = 'block'; 
            } else {
                console.error(`Page with id ${pageId} not found.`);
            }
            
            if (!navLinks) navLinks = document.querySelectorAll('.nav-link'); // v35: 遅延初期化
            navLinks.forEach(link => {
                const isActive = link.dataset.page === pageId;
                link.classList.toggle('bg-red-50', isActive);
                link.classList.toggle('text-red-800', isActive);
                link.classList.toggle('font-semibold', isActive);
            });
        }
        
        // ★ v35: イベントリスナーは DOMContentLoaded の中で登録

        // ----------------------------------------
        // 設定 (★ v34: Firebase対応)
        // ----------------------------------------

        function toggleDataSourceView(source) {
            if (!settingsCsvContainer || !settingsManualContainer) return;
            if (source === 'csv') {
                settingsCsvContainer.style.display = 'block';
                settingsManualContainer.style.display = 'none';
            } else { // 'manual'
                settingsCsvContainer.style.display = 'none';
                settingsManualContainer.style.display = 'block';
            }
        }
        
        // ★ v34: async に変更 (Firestoreに保存)
        async function saveSettings() {
            if (!auth.currentUser) {
                 if (saveStatus) saveStatus.textContent = 'エラー: 認証されていません。';
                 return;
            }
            
            try {
                const settings = {
                    dataSource: dataSourceManual.checked ? 'manual' : 'csv',
                    csvUrls: csvUrlsInput.value.split('\n').filter(url => url.trim() !== ''),
                    mapping: {}
                };
                
                for (const key in mappingInputs) {
                    if (mappingInputs[key]) {
                        const letter = mappingInputs[key].value;
                        settings.mapping[key] = letterToColumn(letter); // "B" -> 2
                    }
                }
                
                const manualData = manualDataInput.value;
                
                // ★ v34: Firestoreドキュメントへのパスを作成
                const settingsRef = doc(db, 'artifacts', appId, 'users', userId, 'settings', SETTINGS_DOC_ID);
                const manualDataRef = doc(db, 'artifacts', appId,
